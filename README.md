---
README.md
author: 晁宇豪 221240013
(1/19更新：文档记录模式)
---


# 抽象飞行棋 Abstract Flight Chess

## 简介：

本游戏借助C++图形库[`EasyX`](https://easyx.cn)实现了GUI，玩法详解请看讲解视频，精彩游戏演示已投稿b站，[视频链接](https://www.bilibili.com/video/BV1cW4y1L7BF/?spm_id_from=333.999.0.0&vd_source=2cdb7b4f48f2dcc6e8f3e32df8bd34cc)。

## 如何运行：

打开`bin`文件夹，直接双击`flight chess.exe`即可开始游玩正常模式

打开`src`文件夹，可以打开`flight chess.sln`查看源码以及开启`god_mode`或者`developer_mode`

## 注意事项：

### 关于单线程：

由于整个游戏内容都没有使用多线程，因此在机器人操作以及在`god_mode`和`DEBUG`操作台输入骰子数时主游戏内容都无法实现游戏画面内部的静音和退出。若有需求请自行开启系统静音。

### 关于`god_mode`：

在`god_mode`下，任何骰子的点数需要玩家在控制台中手动输入，如果你想要实现直接到终点，可以对起点的飞机直接输入56，请不要输入距离终点弹回超过6个位置的骰子点数，这有悖于该飞行棋游戏的根本规则，会引发某种不可知的bug。

## 代码讲解：

### 核心游戏：

考虑到阅读1800行代码对于老师而言非常麻烦，在这里我提供我的核心代码思路讲解。

如果认真看了我的讲解视频，你一定会记得我大概600行就写完了核心游戏，但我视频里面没讲的是，这600行中一半篇幅写给了“冷酷无情的”`master_robot`，还有一小半的篇幅写给了控制音乐，显示文字之类的东西，可以说真正决定飞机飞行逻辑的代码小于100行，那我是如何实现如此高效游戏逻辑呢？

在这里，我使用了一个特殊的量`step`去记录飞机的状态，这个`step`是针对这个角色本身的，不难发现，无论是从哪个角色出发，从第0步开始计算，第1，5，9……步都可以跳棋，第13，17步都可以大跳，第49步是最后一步，50步开始进入最终跑道。

那么我们已经实现了跳棋功能，现在是吃子功能，这时我们就可以发现这一套表达方式最绝妙的地方：
> map_step = (step + start[player]) % 52;

在这里，我们可以通过角色自身的步数`step`快速计算它在棋盘上的位置`map_step`，然后棋子一共也就8-16个，因此我们可以通过10次左右的计算，快速获得公共棋盘上每个棋子的位置，从而实现吃子等一系列功能。

最后就是最终跑道的计算，逻辑也是非常的简单,在这里我们用倒数到终点的距离来计算，每个棋子初始的`last_step`的值都是6，当倒数为0时到达终点
```C++
last_step = last_step - dice_number;
if(last_step < 0) last_step = 0-last_step; // 弹回
if(last_step == 0) achieve(); // 到达终点
```

### 其他：

关于 `master_robot`的设计，以及本游戏中其他比较有意思的部分，例如作为游戏主体的自动机，快速导入坐标的文件处理cpp，本文不再一一赘述，源码中有很多~~言简意赅的~~注释，欢迎阅读源码。

## 声明：
本游戏中选择的8个角色均为网络热门角色，本意是为了玩家角色感更丰富，台词均源自角色本身，（第8个是南大贴吧的战南哥），游戏中并不存在不良引导以及乱带节奏，请放心游玩游戏，享受飞行棋的快乐。